Thanks, its time to get to the business of the Day, I did created a working native module for the react native architechure that hanlde MQTT connection,  disconnection, subscription and publish.

I used react native emitter for emitting events, in the new architechure i guess this will be done differently given that i have showed you what the new arch. native module looks like for android, I will give you the native i did developed in the old architecture for the Mqtt and i expect you revamp to work for a react native new arch project, also define its Specs for codegen support.

I expected that i wont have to use the event listern same way it was used in the old module, because in react native ble Manager package, 

it uses BleManager.onDisconnect() method (exmaple) instale the the regular BleManager.addeventListner('disconnect'). 

MqttModule.kt file :
package com.smartpowerbox

import com.facebook.react.bridge.*
import com.facebook.react.modules.core.DeviceEventManagerModule
import org.eclipse.paho.client.mqttv3.*
import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence
import android.util.Log

class MqttModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {
    private val mqttClient: MqttClient
    private val reactContext: ReactApplicationContext = reactContext
    private var isConnecting = false

    init {
        val brokerUrl = "tcp://41.223.145.80:1883"
        mqttClient = MqttClient(brokerUrl, MqttClient.generateClientId(), MemoryPersistence())

        // Set MQTT callback for connection and disconnection events
        mqttClient.setCallback(object : MqttCallbackExtended {
            override fun connectionLost(cause: Throwable?) {
                Log.e("MqttModule", "Connection lost: ${cause?.message}")
                sendEvent("onDisconnect", Arguments.createMap().apply {
                    putString("error", cause?.message ?: "Unknown error")
                })
                reconnect()
            }

            override fun messageArrived(topic: String?, message: MqttMessage?) {
                sendEvent("onMessage", Arguments.createMap().apply {
                    putString("topic", topic)
                    putString("message", String(message?.payload ?: byteArrayOf()))
                })
            }

            override fun deliveryComplete(token: IMqttDeliveryToken?) {
                // Not used in this implementation
            }

            override fun connectComplete(reconnect: Boolean, serverURI: String?) {
                Log.i("MqttModule", "Connected to broker: $serverURI (reconnect: $reconnect)")
                sendEvent("onConnect", Arguments.createMap().apply {
                    putBoolean("reconnect", reconnect)
                })
            }
        })
    }

    override fun getName(): String {
        return "MqttModule"
    }

    @ReactMethod
    fun addListener(type: String?) {
        // Keep: Required for RN built in Event Emitter Calls.
    }

    @ReactMethod
    fun removeListeners(type: Int?) {
        // Keep: Required for RN built in Event Emitter Calls.
    }

    @ReactMethod
    fun connect(username: String, password: String, promise: Promise) {
        try {
            val options = MqttConnectOptions().apply {
                this.userName = username
                this.password = password.toCharArray()
                this.isAutomaticReconnect = false
            }

            mqttClient.connect(options)
            promise.resolve("Connected to MQTT broker")
        } catch (e: Exception) {
            promise.reject("MQTT_CONNECTION_ERROR", e.message)
        }
    }

    @ReactMethod
    fun subscribe(topic: String, qos: Int, promise: Promise) {
        try {
            mqttClient.subscribe(topic, qos) { t, message ->
                sendEvent("onMessage", Arguments.createMap().apply {
                    putString("topic", t)
                    putString("message", String(message.payload))
                })
            }
            promise.resolve("Subscribed to topic: $topic")
        } catch (e: Exception) {
            promise.reject("MQTT_SUBSCRIPTION_ERROR", e.message)
        }
    }

    @ReactMethod
    fun unsubscribe(topic: String, promise: Promise) {
        try {
            if (mqttClient.isConnected) {
                mqttClient.unsubscribe(topic)
                promise.resolve("Unsubscribed from topic: $topic")
            } else {
                promise.reject("MQTT_UNSUBSCRIBE_ERROR", "Client is not connected")
            }
        } catch (e: Exception) {
            promise.reject("MQTT_UNSUBSCRIBE_ERROR", e.message)
        }
    }

    @ReactMethod
    fun disconnect(promise: Promise) {
        try {
            if (mqttClient.isConnected) {
                mqttClient.disconnect()
                sendEvent("onDisconnect", Arguments.createMap().apply {
                    putString("message", "--Disconnected from MQTT broker--")
                })
                promise.resolve("Disconnected from MQTT broker")
            } else {
                promise.resolve("Already disconnected")
            }
        } catch (e: Exception) {
            promise.reject("MQTT_DISCONNECT_ERROR", e.message)
        }
    }

    @ReactMethod
    fun publish(topic: String, message: String, qos: Int, promise: Promise) {
        try {
            if (mqttClient.isConnected) {
                val mqttMessage = MqttMessage(message.toByteArray()).apply {
                    this.qos = qos
                    // Optionally, set the retain flag if needed:
                    // this.isRetained = true
                }
                mqttClient.publish(topic, mqttMessage)
                promise.resolve("Message published to topic: $topic")
            } else {
                promise.reject("MQTT_PUBLISH_ERROR", "Client is not connected")
            }
        } catch (e: Exception) {
            promise.reject("MQTT_PUBLISH_ERROR", e.message)
        }
    }

    private fun reconnect() {
        if (isConnecting) return
        isConnecting = true

        try {
            Log.i("MqttModule", "Attempting to reconnect to MQTT broker...")
            mqttClient.reconnect()
            isConnecting = false
        } catch (e: Exception) {
            Log.e("MqttModule", "Reconnect failed: ${e.message}")
            isConnecting = false
        }
    }

    private fun sendEvent(eventName: String, params: WritableMap) {
        reactContext
            .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)
            .emit(eventName, params)
    }
}


MqttPackage file :

package com.smartpowerbox

import com.facebook.react.ReactPackage
import com.facebook.react.bridge.NativeModule
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.uimanager.ViewManager

class MqttPackage : ReactPackage {
    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> {
        return listOf(MqttModule(reactContext))
    }

    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {
        return emptyList()
    }
}


package com.smartpowerbox

import com.facebook.react.bridge.*
import com.facebook.react.turbomodule.core.interfaces.TurboModule
import org.eclipse.paho.client.mqttv3.*
import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence
import android.util.Log

class MqttModule(private val context: ReactApplicationContext) :
    NativeMqttSpec(context), TurboModule {

    private val mqttClient: MqttClient
    private var isConnecting = false

    private var onConnectCallback: Callback? = null
    private var onDisconnectCallback: Callback? = null
    private var onMessageCallback: Callback? = null

    init {
        val brokerUrl = "tcp://41.223.145.80:1883"
        mqttClient = MqttClient(brokerUrl, MqttClient.generateClientId(), MemoryPersistence())

        mqttClient.setCallback(object : MqttCallbackExtended {
            override fun connectionLost(cause: Throwable?) {
                Log.e("MqttModule", "Connection lost: ${cause?.message}")
                onDisconnectCallback?.invoke(cause?.message ?: "Unknown error")
                reconnect()
            }

            override fun messageArrived(topic: String?, message: MqttMessage?) {
                onMessageCallback?.invoke(topic ?: "", message?.payload?.decodeToString() ?: "")
            }

            override fun deliveryComplete(token: IMqttDeliveryToken?) {}

            override fun connectComplete(reconnect: Boolean, serverURI: String?) {
                onConnectCallback?.invoke(reconnect)
            }
        })
    }

    override fun getName(): String {
        return "MqttModule"
    }

    override fun connect(username: String, password: String, promise: Promise) {
        try {
            val options = MqttConnectOptions().apply {
                this.userName = username
                this.password = password.toCharArray()
                this.isAutomaticReconnect = false
            }

            mqttClient.connect(options)
            promise.resolve("Connected to MQTT broker")
        } catch (e: Exception) {
            promise.reject("MQTT_CONNECTION_ERROR", e.message)
        }
    }

    override fun disconnect(promise: Promise) {
        try {
            if (mqttClient.isConnected) {
                mqttClient.disconnect()
                onDisconnectCallback?.invoke("Disconnected from MQTT broker")
                promise.resolve("Disconnected")
            } else {
                promise.resolve("Already disconnected")
            }
        } catch (e: Exception) {
            promise.reject("MQTT_DISCONNECT_ERROR", e.message)
        }
    }

    override fun subscribe(topic: String, qos: Int, promise: Promise) {
        try {
            mqttClient.subscribe(topic, qos)
            promise.resolve("Subscribed to topic: $topic")
        } catch (e: Exception) {
            promise.reject("MQTT_SUBSCRIPTION_ERROR", e.message)
        }
    }

    override fun unsubscribe(topic: String, promise: Promise) {
        try {
            mqttClient.unsubscribe(topic)
            promise.resolve("Unsubscribed from topic: $topic")
        } catch (e: Exception) {
            promise.reject("MQTT_UNSUBSCRIBE_ERROR", e.message)
        }
    }

    override fun publish(topic: String, message: String, qos: Int, promise: Promise) {
        try {
            val mqttMessage = MqttMessage(message.toByteArray()).apply {
                this.qos = qos
            }
            mqttClient.publish(topic, mqttMessage)
            promise.resolve("Message published")
        } catch (e: Exception) {
            promise.reject("MQTT_PUBLISH_ERROR", e.message)
        }
    }

    override fun onConnect(callback: Callback) {
        onConnectCallback = callback
    }

    override fun onDisconnect(callback: Callback) {
        onDisconnectCallback = callback
    }

    override fun onMessage(callback: Callback) {
        onMessageCallback = callback
    }

    private fun reconnect() {
        if (isConnecting) return
        isConnecting = true

        try {
            mqttClient.reconnect()
            isConnecting = false
        } catch (e: Exception) {
            isConnecting = false
        }
    }
}


    "name": "NativeLocalStorageSpec",
    "type": "modules",
    "jsSrcsDir": "specs",
    "android": {
      "javaPackageName": "com.technovatepowerbox"
    }